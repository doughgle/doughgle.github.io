<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.111.3"><link rel=icon href=/images/icon.jpg><title>Exploring OCI Container Registries: Chapter 1: Pull a Public Image from Kubernetes | Douglas Hellinger</title><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.douglashellinger.com/explainer/container-oci-registry/pull-a-public-container-image/5-pull-public-image-sequence-cover.drawio.svg"><meta name=twitter:title content="Exploring OCI Container Registries: Chapter 1: Pull a Public Image from Kubernetes"><meta name=twitter:description content="Let&rsquo;s begin with one of the most common use cases of a Container Registry:
Pull A Public Container Image Here&rsquo;s a simple kubernetes cluster.
It has access to pull images from the public internet."><meta property="og:title" content="Exploring OCI Container Registries: Chapter 1: Pull a Public Image from Kubernetes"><meta property="og:description" content="Let&rsquo;s begin with one of the most common use cases of a Container Registry:
Pull A Public Container Image Here&rsquo;s a simple kubernetes cluster.
It has access to pull images from the public internet."><meta property="og:type" content="article"><meta property="og:url" content="https://www.douglashellinger.com/explainer/container-oci-registry/pull-a-public-container-image/"><meta property="og:image" content="https://www.douglashellinger.com/explainer/container-oci-registry/pull-a-public-container-image/5-pull-public-image-sequence-cover.drawio.svg"><meta property="article:section" content="explainer"><meta property="article:published_time" content="2023-08-06T16:00:31+08:00"><meta property="article:modified_time" content="2023-06-10T16:38:31+08:00"><link href=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css rel=stylesheet integrity=sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T crossorigin=anonymous><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.0.13/css/all.css integrity=sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp crossorigin=anonymous><link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel=stylesheet><link rel=stylesheet href=https://www.douglashellinger.com/css/medium.a3d5489836b19de22a81ddc6bd21c17547d07529e67b266427378a04fa3ea727.css integrity="sha256-o9VImDaxneIqgd3GvSHBdUfQdSnmeyZkJzeKBPo+pyc="><link rel=stylesheet href=https://www.douglashellinger.com/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk="></head><body><nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down"><div class="container pr-0"><a class=navbar-brand href=https://www.douglashellinger.com/><img src=/images/icon.jpg alt=logo></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarMediumish aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarMediumish><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/blog>Blog</a></li><li class=nav-item><a class=nav-link href=/explainer>Explainers</a></li><li class=nav-item><a class=nav-link href=/food>Food</a></li><li class=nav-item><a class=nav-link href=/how-to>How to Guides</a></li><li class=nav-item><a class=nav-link href=/>About</a></li></ul></div></div></nav><div class=site-content><div class=container><div class=mainheading><h1 class=sitetitle>Douglas Hellinger</h1><p class=lead>Helping you have fun and maximise impact by learning containers and kubernetes!</p></div><div class=main-content><div class=container><div class=row><div class="col-md-2 pl-0"><div class="share sticky-top sticky-top-offset"><p>Share</p><ul><li class="ml-1 mr-1"><a target=_blank href="https://twitter.com/intent/tweet?text=Exploring%20OCI%20Container%20Registries%3a%20Chapter%201%3a%20Pull%20a%20Public%20Image%20from%20Kubernetes&url=https%3a%2f%2fwww.douglashellinger.com%2fexplainer%2fcontainer-oci-registry%2fpull-a-public-container-image%2f" onclick='return window.open(this.href,"twitter-share","width=550,height=435"),!1'><i class="fab fa-twitter"></i></a></li><li class="ml-1 mr-1"><a target=_blank href="https://facebook.com/sharer.php?u=https%3a%2f%2fwww.douglashellinger.com%2fexplainer%2fcontainer-oci-registry%2fpull-a-public-container-image%2f" onclick='return window.open(this.href,"facebook-share","width=550,height=435"),!1'><i class="fab fa-facebook-f"></i></a></li><li class="ml-1 mr-1"><a target=_blank href="https://www.xing.com/spi/shares/new?url=https%3a%2f%2fwww.douglashellinger.com%2fexplainer%2fcontainer-oci-registry%2fpull-a-public-container-image%2f" onclick='return window.open(this.href,"xing-share","width=550,height=435"),!1'><i class="fab fa-xing"></i></a></li></ul><div class=sep></div><ul><li><a class="small smoothscroll" href=#disqus_thread></a></li></ul></div></div><div class="col-md-9 flex-first flex-md-unordered"><div class=mainheading><div class="row post-top-meta"><div class="col-xs-12 col-md-3 col-lg-2 text-center text-md-left mb-4 mb-md-0 md-nopad-right"><img class=author-thumb src=/images/profile.jpg alt="Douglas Hellinger"></div><div class="col-xs-12 col-md-9 col-lg-10 text-center text-md-left md-nopad-left"><a target=_blank class=link-dark>Douglas Hellinger</a><br><span class=author-description>Creator of this blog.<br><i class="far fa-star"></i>
Aug 6, 2023
<i class="far fa-clock clock"></i>
12 min read</span></div></div><h1 class=posttitle>Exploring OCI Container Registries: Chapter 1: Pull a Public Image from Kubernetes</h1></div><img class="featured-image img-fluid" src=https://www.douglashellinger.com/explainer/container-oci-registry/pull-a-public-container-image/5-pull-public-image-sequence-cover.drawio.svg alt="thumbnail for this post"><div class=article-post><p>Let&rsquo;s begin with one of the most common use cases of a Container Registry:</p><h2 id=pull-a-public-container-image>Pull A Public Container Image</h2><p>Here&rsquo;s a simple kubernetes cluster.</p><p>It has access to pull images from the public internet.</p><p><img src=./1-simple-k8s-pull-from-public.drawio.svg alt="Block Diagram showing a Simple Kubernetes Cluster Pulls From DockerHub" title="Lonely world: a 1 node k8s cluster"></p><p>Let&rsquo;s create a simple pod that runs <code>hello-world</code> to completion</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>âžœ kubectl run hello <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --image<span style=color:#f92672>=</span>hello-world <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --restart<span style=color:#f92672>=</span>Never
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>pod/hello created
</span></span></code></pre></div><h3 id=q-where-does-the-image-come-from>Q: Where Does The Image Come From?</h3><p>To find out, we can examine the logs of the high-level container runtime (sometimes called the container engine).
Our OCI Runtime is <a href=https://github.com/containerd/containerd>Containerd</a>.</p><p><code>containerd.log</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;msg&#34;</span>: <span style=color:#e6db74>&#34;PullImage \&#34;hello-world:latest\&#34;&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;msg&#34;</span>: <span style=color:#e6db74>&#34;PullImage using normalized image ref: \&#34;docker.io/library/hello-world:latest\&#34;&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;host&#34;</span>: <span style=color:#e6db74>&#34;registry-1.docker.io&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;msg&#34;</span>: <span style=color:#e6db74>&#34;resolving&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;host&#34;</span>: <span style=color:#e6db74>&#34;registry-1.docker.io&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;msg&#34;</span>: <span style=color:#e6db74>&#34;do request&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;request.header.accept&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.docker.distribution.manifest.v2+json, application/vnd.docker.distribution.manifest.list.v2+json, application/vnd.oci.image.manifest.v1+json, application/vnd.oci.image.index.v1+json, */*&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;request.method&#34;</span>: <span style=color:#e6db74>&#34;HEAD&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;url&#34;</span>: <span style=color:#e6db74>&#34;https://registry-1.docker.io/v2/library/hello-world/manifests/latest&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the Containerd logs, we can see the <code>hello-world</code> image is <strong>normalised</strong>.</p><p>Specifically, its:</p><ol><li>prefixed with the default registry <code>docker.io</code></li><li>prefixed with the default repository <code>library</code></li><li>suffixed with the default tag <code>latest</code></li></ol><p><img src=./1b-normalised-image-reference.drawio.svg alt="Diagram showing Anatomy Of An OCI Image Reference" title="Immortal words: hello world"></p><p>Containerd requests the image from <code>registry-1.docker.io</code>, better known as DockerHub.</p><h3 id=q-how-did-the-image-get-from-the-registry-to-the-container-runtime>Q: How Did The Image Get From The Registry To The Container Runtime?</h3><p>An OCI Image is composed of a <strong>Manifest</strong>, one or more <strong>Filesystem Layers</strong> and an <strong>Image Configuration</strong>.</p><p>When Containerd receives a request to run a container from an image, here&rsquo;s a model of what happens:</p><p><img src=./5-pull-public-image-sequence.drawio.svg alt="Sequence Diagram showing CRI Containerd Pulling a public container image from Dockerhub OCI Registry" title="Container runtime and registry chatting away!"></p><details><summary><strong>Click to Expand:</strong> Steps describing Containerd Runtime Pulling a Public Container Image from Dockerhub OCI Registry</summary><ol><li><p>First, Containerd makes a <code>HEAD</code> request to DockerHub at <code>/v2/library/hello-world/manifests/latest?ns=docker.io</code> for <code>hello-world:latest</code>. We say it &ldquo;fetches the <strong>Manifest Digest</strong>&rdquo; for the <code>latest</code> tag.</p></li><li><p>DockerHub responds with the sha256 digest of the <strong>OCI Image Manifest</strong>.</p></li><li><p>Is the Manifest already present on the Containerd host? Nope. No <code>hello-world:latest</code> manifest exists locally.</p></li><li><p>Download the Image Manifest. Specifically, Containerd makes a <code>GET</code> request to Dockerhub at <code>/v2/library/hello-world/manifests/sha256:a8281ce42034b078dc7d88a5bfe6d25d75956aad9abba75150798b90fa3d1010?ns=docker.io</code>. Notice its the same <code>manifests</code> API but this time its a <code>GET</code> request for the manifest identified by its sha256 digest.</p></li><li><p>DockerHub responds with the actual <strong>OCI Image Manifest</strong> document.</p></li><li><p>Containerd verifies the Manifest&rsquo;s actual digest against the requested one. Has it been modified in transit? In particular, it computes the sha256sum of the manifest json content (<code>application/vnd.oci.image.manifest.v1+json</code>) received and compares it to the sha256 digest that identifies the manifest.</p></li><li><p>Second, is the <strong>Image Configuration</strong> already present on the Containerd host?
In particular, Containerd takes the <strong>Image Configuration</strong> digest from the Manifest and searches for it in the <code>io.containerd.content.v1.content/blobs</code> directory on the host machine.</p><ol><li><p>Its not present. Download. Specifically, Containerd makes a GET request to the <code>blobs</code> API endpoint e.g. <code>/v2/library/hello-world/blobs/sha256:9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d</code></p></li><li><p>Verify checksum of the <strong>Image Configuration</strong> against manifest.</p></li></ol></li><li><p>Third, for each <strong>Filesystem Layer</strong> in the manifest:</p><ol><li><p>Is the layer already present on the worker?</p></li><li><p>Download. Specifically, Containerd makes a GET request to the <code>blobs</code> API endpoint e.g. <code>/v2/library/hello-world/blobs/sha256:2af0ea4a9556b049337d026dd7df7f9c20661203c634be4f9b976814c05e5c32?ns=docker.io</code></p></li><li><p>Verify checksum against manifest.</p></li><li><p>Extract.</p></li></ol></li></ol><blockquote><p>* If more than one target platform (architecture and os) exists for the image, there&rsquo;s another layer of indirection. Containerd requests and processes an <strong>OCI Image Index</strong> (<code>application/vnd.oci.image.index.v1+json</code>), which itself returns the <strong>Manifest Digest</strong> for the requested target platform. (Omitted here for simplicity)</p><p>** In practice, downloads happen in parallel. Simplified here for illustration.</p></blockquote></details><p>Did you notice how Containerd precedes each GET request with a check for local presence?</p><p>This enables the opportunity for better <strong>efficiency</strong>.</p><p>Each OCI Image component is identifiable by its sha256 digest. That digest is derived purely from its content, not by its location.</p><p>Containerd applies this knowledge to automatically reduce waste in downloading OCI Image components from the registry. In particular, if a component of the OCI Image exists locally then Containerd skips the download.</p><p>We can see an example of the pull sequence using <code>ctr</code>, the <a href=https://github.com/projectatomic/containerd/blob/master/docs/cli.md>CLI client for Containerd</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># ctr image pull \</span>
</span></span><span style=display:flex><span>  docker.io/library/hello-world:latest
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>docker.io/library/hello-world:latest:                                             resolved       |++++++++++++++++++++++++++++++++++++++| 
</span></span><span style=display:flex><span>index-sha256:926fac19d22aa2d60f1a276b66a20eb765fbeea2db5dbdaafeb456ad8ce81598:    <span style=color:#66d9ef>done</span>           |++++++++++++++++++++++++++++++++++++++| 
</span></span><span style=display:flex><span>manifest-sha256:7e9b6e7ba2842c91cf49f3e214d04a7a496f8214356f41d81a6e6dcad11f11e3: <span style=color:#66d9ef>done</span>           |++++++++++++++++++++++++++++++++++++++| 
</span></span><span style=display:flex><span>layer-sha256:719385e32844401d57ecfd3eacab360bf551a1491c05b85806ed8f1b08d792f6:    <span style=color:#66d9ef>done</span>           |++++++++++++++++++++++++++++++++++++++| 
</span></span><span style=display:flex><span>config-sha256:9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d:   <span style=color:#66d9ef>done</span>           |++++++++++++++++++++++++++++++++++++++| 
</span></span><span style=display:flex><span>elapsed: 4.8 s                                                                    total:  2.5 Ki <span style=color:#f92672>(</span>533.0 B/s<span style=color:#f92672>)</span>                                       
</span></span><span style=display:flex><span>unpacking linux/amd64 sha256:926fac19d22aa2d60f1a276b66a20eb765fbeea2db5dbdaafeb456ad8ce81598...
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>: 7.66556ms
</span></span></code></pre></div><p>The Container Runtime first downloads the Image Index, then the Image Manifest. The Image Manifest contains digests of the Layers and the Configuration. The layers are blobs (binary large objects). The Index, Manifest and Config are JSON documents.</p><p>The Container Runtime can detect changes in a Manifest, Layer or Configuration by computing the content digest (<code>sha256sum [FILE]</code>) and comparing it to the identifier digest.</p><p>ðŸ’¡ If the digests match, there are no changes. Its the same content. It doesn&rsquo;t matter where you download it from or where you store it! *.</p><p>This design choice is called <a href=https://en.wikipedia.org/wiki/Content-addressable_storage>Content Addressable Storage</a>.</p><ul><li>Content Addressable storage can enable better distribution and storage efficiency in Registry and Runtime.</li></ul><blockquote><p>* Instead, what matters is a way to trust the creator of the image. If you can trust the digest of the initial Image Index or Image Manifest, then you can trust the rest of the content! In practice, this is typically achieved by signing images.</p></blockquote><hr><h2 id=more-clusters-more-image-pulls>More Clusters, More Image Pulls</h2><p>Imagine an organisation has 6 application teams.</p><p>Each team has their own cluster so they can operate independently on their own cadence.</p><p>Again, each cluster has access to pull images from the public internet.</p><p><img src=./2-more-clusters-pull-from-public.drawio.svg alt="Diagram showing Multi-node Clusters Pull From Public Registry" title="Pull party: workers all wanna attract the same image!"></p><p>Actually, each team wants to run a job that tests a matrix of 3 image versions.</p><p>Additionally, it must run to completion exactly 6 times and must complete quickly.</p><p>Finally, these images have mutable tags and its important to test with the freshest.</p><p>Here&rsquo;s the job specification:</p><p><code>hello-job.yaml</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Job</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>completions</span>: <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>parallelism</span>: <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>activeDeadlineSeconds</span>: <span style=color:#ae81ff>600</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>hello</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>hello-world:linux</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello-linux</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>imagePullPolicy</span>: <span style=color:#ae81ff>Always</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>hello-world:nanoserver-ltsc2022</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello-nanoserver</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>imagePullPolicy</span>: <span style=color:#ae81ff>Always</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>hello-world:nanoserver-1809</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>imagePullPolicy</span>: <span style=color:#ae81ff>Always</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>Never</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>affinity</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>podAntiAffinity</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>requiredDuringSchedulingIgnoredDuringExecution</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>labelSelector</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>matchExpressions</span>:
</span></span><span style=display:flex><span>              - <span style=color:#f92672>key</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>operator</span>: <span style=color:#ae81ff>In</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>values</span>:
</span></span><span style=display:flex><span>                - <span style=color:#ae81ff>hello</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>topologyKey</span>: <span style=color:#ae81ff>kubernetes.io/hostname</span>
</span></span></code></pre></div><p>Monday, first thing, the teams deploy the jobs. What happens next?</p><hr><h2 id=problem-errimagepull-hit-the-limit>Problem: <code>Errimagepull</code>, Hit The Limit</h2><p>Two minutes later, we&rsquo;re seeing ErrImagePull errors&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ kubectl get events
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>90s         Warning   Failed                    pod/hello-zhkp7               
</span></span><span style=display:flex><span>Failed to pull image <span style=color:#e6db74>&#34;hello-world:nanoserver&#34;</span>: 
</span></span><span style=display:flex><span>rpc error: code <span style=color:#f92672>=</span> Unknown desc <span style=color:#f92672>=</span> failed to pull and unpack image <span style=color:#e6db74>&#34;docker.io/library/hello-world:nanoserver&#34;</span>: 
</span></span><span style=display:flex><span>failed to copy: httpReadSeeker: failed open: 
</span></span><span style=display:flex><span>unexpected status code https://registry-1.docker.io/v2/library/hello-world/manifests/sha256:3cabdfb783cd2710153b3824ba5d94c8ebecc0bc48251e2e823f82a15dec660f: 
</span></span><span style=display:flex><span><span style=color:#ae81ff>429</span> Too Many Requests - Server message: 
</span></span><span style=display:flex><span>toomanyrequests: You have reached your pull rate limit. You may increase the limit by authenticating and upgrading: https://www.docker.com/increase-rate-limit
</span></span></code></pre></div><p>If we examine the events, we got a <code>429 Too Many Requests</code> response from DockerHub.</p><p>DockerHub <a href=https://docs.docker.com/docker-hub/download-rate-limit/>limits the number of container image pulls</a> based on the account type of the user pulling the image. DockerHub identifies anonymous (i.e. unauthenticated) users by their source IP address.</p><p>To summarise:</p><table><thead><tr><th>Account Type</th><th>Limit</th></tr></thead><tbody><tr><td>anonymous users</td><td>100 pulls per 6 hours per IP address.</td></tr><tr><td>authenticated users</td><td>200 pulls per 6 hour period.</td></tr><tr><td>Users with a paid Docker subscription</td><td>5000 pulls per day.</td></tr></tbody></table><p>We can visualise the remaining requests with the handy <a href=https://gitlab.com/gitlab-da/unmaintained/docker-hub-limit-exporter>Docker Hub Rate Limit Exporter for Prometheus</a>.</p><p><img src=./hit-the-limit.png alt="Grafana Dashboard Showing we hit the Dockerhub Pull Limit!" title="Blow a ton: 100 image pull requests gone in 2 mins!"></p><p>Yup, Remaining Requests is 0! We hit the DockerHub rate limit!</p><p>How did that happen?</p><ol><li>we have 6 clusters</li><li>each cluster has 6 worker nodes</li><li>each team deployed a job that ran 6 <code>hello</code> pods to completion, in parallel - fancy stuff!</li><li>for freshness, each hello-world pod <code>Always</code> attempts to pull 3 versions of the <code>hello-world</code> image.</li></ol><p>That&rsquo;s <strong>6 clusters * 6 pods * 3 containers = 108 image pulls</strong></p><p><img src=./3-too-many-workers-pull-from-public.drawio.svg alt="Diagram showing Too Many Clusters Pull Directly From Dockerhub" title="Heavy traffic on the Containerway"></p><h3 id=q-what-_is_-an-image-pull-request>Q: What <em>is</em> An Image Pull Request?</h3><p>ðŸ’¡ An Image <strong>Pull Request</strong> is <a href=https://docs.docker.com/docker-hub/download-rate-limit/#definition-of-limits>defined by Docker Inc.</a> as:</p><ul><li>One or two <code>GET</code> requests on registry manifest URLs (<code>/v2/*/manifests/*</code>).</li><li>There&rsquo;ll be two requests if there&rsquo;s an Image Index.</li><li><code>HEAD</code> requests arenâ€™t counted.</li></ul><h3 id=q-what-about-the-6-worker-nodes-why-is-that-significant>Q: What About The 6 Worker Nodes? Why Is That Significant?</h3><p>Kubernetes spreads the 6 pods across the worker nodes because of the <code>podAntiAffinity</code> rule in the pod spec.</p><p>The <code>hello-world</code> OCI Images don&rsquo;t exist on a worker node by default.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># ctr images list --quiet | grep hello-world</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh></code></pre></div><p>Before it can create and start a container, each worker must pull the image from DockerHub.</p><p>Its significant because Dockerhub receives many requests in a short time frame.</p><p>But each worker has its own IP address on the network.</p><p>Why then does Dockerhub identify them as one single unauthenticated puller?</p><h3 id=q-why-are-workers-sharing-the-dockerhub-limit>Q: Why Are Workers Sharing The Dockerhub Limit?</h3><p>Let&rsquo;s examine the response from DockerHub.</p><p>Again, from the Containerd logs, the response looks like this:</p><p><code>containerd.log</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;host&#34;</span>: <span style=color:#e6db74>&#34;registry-1.docker.io&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;msg&#34;</span>: <span style=color:#e6db74>&#34;fetch response received&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;response.header.content-length&#34;</span>: <span style=color:#e6db74>&#34;2561&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;response.header.content-type&#34;</span>: <span style=color:#e6db74>&#34;application/vnd.docker.distribution.manifest.list.v2+json&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;response.header.docker-content-digest&#34;</span>: <span style=color:#e6db74>&#34;sha256:fc6cf906cbfa013e80938cdf0bb199fbdbb86d6e3e013783e5a766f50f5dbce0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;response.header.docker-distribution-api-version&#34;</span>: <span style=color:#e6db74>&#34;registry/2.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;response.header.docker-ratelimit-source&#34;</span>: <span style=color:#e6db74>&#34;58.185.1.1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;response.header.etag&#34;</span>: <span style=color:#e6db74>&#34;\&#34;sha256:fc6cf906cbfa013e80938cdf0bb199fbdbb86d6e3e013783e5a766f50f5dbce0\&#34;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;response.header.ratelimit-limit&#34;</span>: <span style=color:#e6db74>&#34;100;w=21600&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;response.header.ratelimit-remaining&#34;</span>: <span style=color:#e6db74>&#34;99;w=21600&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;response.header.strict-transport-security&#34;</span>: <span style=color:#e6db74>&#34;max-age=31536000&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;response.status&#34;</span>: <span style=color:#e6db74>&#34;200 OK&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;url&#34;</span>: <span style=color:#e6db74>&#34;https://registry-1.docker.io/v2/library/hello-world/manifests/latest&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Notice the <code>response.header.docker-ratelimit-source</code>. Its <code>58.185.1.1</code>.</p><p>Thats the public IP address of the network&rsquo;s internet gateway. Its the source address that DockerHub sees.</p><p>This happens if <a href=https://www.netfilter.org/documentation/HOWTO/NAT-HOWTO-6.html#ss6.1>Source Network Address Translation (SNAT)</a> is configured for outbound internet requests.</p><p>This is the case on your home internet router. In particular, it uses Masquerading, which is a special case of SNAT where the source address need not be specified - ideal for cases when the networ interface is assigned a public IP address dynamically.</p><p><img src=./4-pulls-from-snat-gateway.drawio.svg alt="Diagram showing Many Clusters share the same Source IP address of the NAT Gateway" title="Is that a hole in your network or is it a gateway to heaven?!"></p><p>The result is each request has the same IP address no matter which cluster originates the request.</p><p>If you&rsquo;re in an organisation with many clusters, and those clusters pull images from Dockerhub through a SNAT gateway,
in the same way, you can hit the limit very quickly!</p><h2 id=q-how-might-we-work-around-the-pull-limit>Q: How Might We Work Around The Pull Limit?</h2><p>There are a couple of alternatives to DockerHub here:</p><h3 id=1-pull-from-a-different-public-registry>1. Pull From A Different Public Registry</h3><blockquote><p>If you&rsquo;re using AWS EKS, you can pull the majority of popular docker images from ECR Public Registry.</p><p>For example <code>docker pull public.ecr.aws/docker/library/hello-world:latest</code></p><p>On AWS, its logically closer to your infrastructure and you wont encounter any rate limiting.</p></blockquote><h3 id=2-operate-your-own-private-oci-registry>2. Operate Your Own Private OCI Registry</h3><blockquote><p>If you already have a central binary repository in your org like a managed Artifactory, Nexus or the Harbor, you&rsquo;re likely already doing this.</p><p>For example <code>docker pull containers.your.org/library/hello-world:latest</code></p><p>This solution becomes increasingly compelling as your container consumption grows.</p></blockquote><p>We&rsquo;re gonna choose option #2, but we wont use a vendor product because we wanna learn with the simplest components that meet the OCI specifications!</p><h2 id=create-a-private-proxy-cache-oci-registry-for-dockerhub>Create A Private Proxy Cache OCI Registry For Dockerhub</h2><p>The simplest OCI Registry is a container running the <code>registry:2</code> image from <a href=https://github.com/distribution/distribution/releases>distribution/distribution</a> :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>k3d registry create docker-io-mirror <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--image docker.io/library/registry:2 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--port 0.0.0.0:5005 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--proxy-remote-url https://registry-1.docker.io <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--volume /tmp/reg:/var/lib/registry <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--volume <span style=color:#66d9ef>$(</span>pwd<span style=color:#66d9ef>)</span>/registry-config.yml:/etc/docker/registry/config.yml <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>--no-help
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>INFO<span style=color:#f92672>[</span>0000<span style=color:#f92672>]</span> Creating node <span style=color:#e6db74>&#39;k3d-docker-io-mirror&#39;</span>         
</span></span><span style=display:flex><span>INFO<span style=color:#f92672>[</span>0000<span style=color:#f92672>]</span> Successfully created registry <span style=color:#e6db74>&#39;k3d-docker-io-mirror&#39;</span> 
</span></span><span style=display:flex><span>INFO<span style=color:#f92672>[</span>0000<span style=color:#f92672>]</span> Starting Node <span style=color:#e6db74>&#39;k3d-docker-io-mirror&#39;</span>         
</span></span><span style=display:flex><span>INFO<span style=color:#f92672>[</span>0000<span style=color:#f92672>]</span> Successfully created registry <span style=color:#e6db74>&#39;k3d-docker-io-mirror&#39;</span> 
</span></span></code></pre></div><p>Initially, the registry is empty:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># wget k3d-docker-io-mirror:5000/v2/_catalog -qO-</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;repositories&#34;</span>: <span style=color:#f92672>[]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Next, let&rsquo;s pull the image again from one of our kubernetes worker using <code>ctr</code>.</p><p>This time we&rsquo;ll pull it from our brand new private OCI Registry.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># ctr image pull \</span>
</span></span><span style=display:flex><span>  --plain-http <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  k3d-docker-io-mirror:5000/library/hello-world:linux
</span></span></code></pre></div><p>Notice we need to specify both the <strong>registry</strong> and <strong>repository</strong> prefix explicitly in the image identifier.</p><p><img src=./6b-specify-full-image-reference.drawio.svg alt="Diagram showing full OCI Image Reference specified for private registry" title="hello world: 17 points in Scrabble"></p><p>Indeed, the normalisation to docker.io and library are historical hangovers from the era when Docker&rsquo;s official images on Dockerhub were the only game in town!</p><p>And here&rsquo;s the output of <code>ctr image pull</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>k3d-docker-io-mirror:5000/library/hello-world:linux:                              resolved       |++++++++++++++++++++++++++++++++++++++| 
</span></span><span style=display:flex><span>index-sha256:726023f73a8fc5103fa6776d48090539042cb822531c6b751b1f6dd18cb5705d:    <span style=color:#66d9ef>done</span>           |++++++++++++++++++++++++++++++++++++++| 
</span></span><span style=display:flex><span>manifest-sha256:7e9b6e7ba2842c91cf49f3e214d04a7a496f8214356f41d81a6e6dcad11f11e3: <span style=color:#66d9ef>done</span>           |++++++++++++++++++++++++++++++++++++++| 
</span></span><span style=display:flex><span>config-sha256:9c7a54a9a43cca047013b82af109fe963fde787f63f9e016fdc3384500c2823d:   <span style=color:#66d9ef>done</span>           |++++++++++++++++++++++++++++++++++++++| 
</span></span><span style=display:flex><span>layer-sha256:719385e32844401d57ecfd3eacab360bf551a1491c05b85806ed8f1b08d792f6:    <span style=color:#66d9ef>done</span>           |++++++++++++++++++++++++++++++++++++++| 
</span></span><span style=display:flex><span>elapsed: 5.3 s                                                                    total:  4.9 Ki <span style=color:#f92672>(</span>952.0 B/s<span style=color:#f92672>)</span>                                       
</span></span><span style=display:flex><span>unpacking linux/amd64 sha256:726023f73a8fc5103fa6776d48090539042cb822531c6b751b1f6dd18cb5705d...
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>: 40.463514ms
</span></span></code></pre></div><p>Notice also that the first pull from the empty registry took <strong>5.3 seconds</strong>.</p><p>Let&rsquo;s see if <code>hello-world</code> is there in the k3d-docker-io-mirror&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>âžœ wget k3d-docker-io-mirror:5000/v2/_catalog -qO-
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;repositories&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;library/hello-world&#34;</span>
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It is!</p><p>Our private registry cached the image.</p><h2 id=repeat-the-experiment-6-clusters-x-6-pods-x-3-containers--108-image-pulls>Repeat The Experiment: 6 Clusters x 6 Pods x 3 Containers = 108 Image Pulls</h2><p>Now we have a private registry working, let&rsquo;s turn our attention back to our multi-cluster test scenario.</p><p>We&rsquo;re gonna repeat the experiment.</p><p>Let&rsquo;s update the images in the pod spec to pull from our private registry.</p><p>Here&rsquo;s the updated job specification:</p><p><code>hello-job-private-reg.yaml</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Job</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>completions</span>: <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>parallelism</span>: <span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>activeDeadlineSeconds</span>: <span style=color:#ae81ff>600</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>app</span>: <span style=color:#ae81ff>hello</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k3d-docker-io-mirror:5000/library/hello-world:linux</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello-linux</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>imagePullPolicy</span>: <span style=color:#ae81ff>Always</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>k3d-docker-io-mirror:5000/library/hello-world:nanoserver-ltsc2022</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello-nanoserver</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>imagePullPolicy</span>: <span style=color:#ae81ff>Always</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>Never</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>affinity</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>podAntiAffinity</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>requiredDuringSchedulingIgnoredDuringExecution</span>:
</span></span><span style=display:flex><span>          - <span style=color:#f92672>labelSelector</span>:
</span></span><span style=display:flex><span>              <span style=color:#f92672>matchExpressions</span>:
</span></span><span style=display:flex><span>              - <span style=color:#f92672>key</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>operator</span>: <span style=color:#ae81ff>In</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>values</span>:
</span></span><span style=display:flex><span>                - <span style=color:#ae81ff>hello</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>topologyKey</span>: <span style=color:#ae81ff>kubernetes.io/hostname</span>
</span></span></code></pre></div><p>After re-applying the <code>hello</code> from private registry job definition, the container runtime should pull the image from our private OCI registry.</p><p><img src=./6-pulls-from-local-registry-mirror.drawio.svg alt="Diagram showing Clusters pull public images from a local registry mirror" title="Go green: with a registry mirror"></p><p>But is there any difference from the first time?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl describe pod hello-vksvd
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Reason                       Message
</span></span><span style=display:flex><span>  ------                       -------
</span></span><span style=display:flex><span>  Scheduled                    Successfully assigned default/hello-vksvd to k3d-cluster-5-agent-2
</span></span><span style=display:flex><span>  Pulling                      Pulling image <span style=color:#e6db74>&#34;k3d-docker-io-mirror:5000/library/hello-world:linux&#34;</span>
</span></span><span style=display:flex><span>  Pulled                       Successfully pulled image <span style=color:#e6db74>&#34;k3d-docker-io-mirror:5000/library/hello-world:linux&#34;</span> in 1.316861913s <span style=color:#f92672>(</span>1.316868009s including waiting<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  Created                      Created container hello-linux
</span></span><span style=display:flex><span>  Started                      Started container hello-linux
</span></span></code></pre></div><p>Yup! This time its 1.3 seconds! What happened?</p><p>Here&rsquo;s what happened exactly:</p><p><img src=./7-seq-pull-public-image-from-private-registry.drawio.svg alt="Sequence Diagram showing Pull Public Image from local registry mirror" title="Mirror mirror on the www..."></p><ol><li>Fetch the <strong>OCI Image Manifest</strong> digest. <strong>Containerd</strong> makes a HEAD request to the registry mirror at <code>/v2/library/hello-world/manifests/linux?ns=docker.io</code>.</li><li><strong>docker-io-mirror</strong> forwards the HEAD request to Dockerhub to check if the digest for the tag <code>linux</code> has changed.</li><li><strong>Dockerhub</strong> responds with the sha256 digest of the Image Manifest.</li><li><strong>docker-io-mirror</strong> then responds with the sha256 digest of the Image Manifest.</li></ol><p>Since <code>hello-world:linux</code> already exists in the Private Registry, it made only one <code>HEAD</code> request to Dockerhub to fetch the identity of the Manifest - its sha256 digest.</p><p>The manifest&rsquo;s sha256 digest is all that&rsquo;s needed to determine that nothing had changed. All of the required layers and configuration are already present on docker-io-mirror.</p><p>The result is faster pulls. There are fewer requests to Dockerhub and we get lower latency on requests for manifest and layer downloads from the local Registry Mirror.</p><p>How about the <code>nanoserver-ltsc2022</code> image?</p><p><img src=./8-seq-pull-public-image-platform-not-supported.drawio.svg alt="Sequence Diagram showing Container Runtime Requests Unsupported Platform Image" title="a HEAD we GET"></p><ol><li>Containerd receives the Image Index in reponse to the Manifest Download.</li><li>Containerd determines there&rsquo;s no matching <strong>Manifest</strong> for platform (linux, amd64) in the <strong>Image Index</strong>.</li></ol><p>It&rsquo;s a Windows image so Containerd won&rsquo;t pull it on Linux and it won&rsquo;t pull it on Mac. However, it will still make a GET request to the registry for the Image Index and that will counted as a pull by DockerHub.</p><h2 id=q-what-happened-to-our-docker-pull-requests-limit-now>Q: What Happened To Our Docker Pull Requests Limit Now?</h2><p><code>--image-pull-policy=Always</code> insists Containerd to pull from the registry rather than use the image stored locally on the worker.</p><p>Since each container in our pod spec has <code>imagePullPolicy: Always</code>, we can expect Containerd to pull from our private registry on each container create operation.</p><p><img src=./hit-dockerhub-with-2-requests-used.png alt="Grafana Dashboard Showing we used only 2 pull requests of our Dockerhub Pull Limit!" title="Image Pull Requests: Your mileage may vary!"></p><p>This time, it used only 2 pull requests!</p><ol><li><p>One to GET the Image Index and Manifest for <code>hello-world:linux</code>. Containerd made these GET requests when we used <code>ctr</code> to pre-pull the image.</p><blockquote><p>Remember: 1 Dockerhub pull request is one or two <code>GET</code> requests on registry manifest URLs (<code>/v2/*/manifests/*</code>).</p></blockquote></li><li><p>One to GET the Image Index for <code>hello-world:nanoserver-ltsc2022</code>.
Containerd determines it&rsquo;s platform (architecture and os) are not supported for this image.</p></li></ol><hr><p>Thank you for reading this article right to the end.
If you enjoyed it and if you think others can benefit, please like and share!</p><p>If you&rsquo;d like to learn from a hands-on-keyboard tutorial for this chapter, let me know on <a href=https://www.linkedin.com/in/doughellinger/>LinkedIn</a>.</p><p>If you foresee a problem, have an alternative solution, I&rsquo;d appreciate your feedback. Again, reach me on <a href=https://www.linkedin.com/in/doughellinger/>LinkedIn</a>.</p><p>Special thank you to <a href=https://www.linkedin.com/in/danielepolencic/>Dan Polencic</a>. Appreciate the reviews and all your feedback!</p><p>Look out for the next chapter&mldr; <a href=../pull-a-public-helm-chart/>Exploring OCI Container Registries: Chapter 2: Pull a Public Helm Chart</a></p><hr><a rel=license href=https://creativecommons.org/licenses/by/4.0/><img alt="Creative Commons Licence" style=border-width:0 src=https://i.creativecommons.org/l/by/4.0/88x31.png></a><br>Except where otherwise noted, all original <span xmlns:dct=http://purl.org/dc/terms/ href=http://purl.org/dc/dcmitype/StillImage rel=dct:type>content</span> by
<a xmlns:cc=http://creativecommons.org/ns# href=https://www.douglashellinger.com/ property="cc:attributionName" rel=cc:attributionurl>Douglas Hellinger</a> is licensed under a
<a rel=license href=https://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International
License</a>.</div><div class=after-post-tags><ul class=tags><li><a href=/tags/oci>oci</a></li><li><a href=/tags/container>container</a></li><li><a href=/tags/runtime>runtime</a></li><li><a href=/tags/registry>registry</a></li><li><a href=/tags/cri>cri</a></li><li><a href=/tags/distribution>distribution</a></li><li><a href=/tags/kubernetes>kubernetes</a></li></ul></div><div class="row PageNavigation d-flex justify-content-between font-weight-bold"><a class="d-block col-md-6" href=https://www.douglashellinger.com/explainer/container-oci-registry/pull-a-public-helm-chart/>&#171; Exploring OCI Registries: Chapter 2: Install a Public Helm Chart on a Private Kubernetes Cluster</a>
<a class="d-block col-md-6 text-lg-right" href=https://www.douglashellinger.com/explainer/docs-as-code-build-pipeline-explained/>Docs-as-code Build Pipeline Explained: From Crazy to Consistent &#187;</a><div class=clearfix></div></div></div></div></div><div class=container><div id=comments class="row justify-content-center mb-5"><div class=col-md-8></div></div></div></div></div><div class="jumbotron fortags"><div class="d-md-flex h-100"><div class="col-md-4 transpdark align-self-center text-center h-100"><div class="d-md-flex align-items-center justify-content-center h-100"><h2 class="d-md-block d-none align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">â†’</span></h2></div></div><div class="col-md-8 p-5 align-self-center text-center"><a class="mt-1 mb-1" href=/tags/429>429</a>
<a class="mt-1 mb-1" href=/tags/ai>ai</a>
<a class="mt-1 mb-1" href=/tags/build-pipeline>build-pipeline</a>
<a class="mt-1 mb-1" href=/tags/builder-image>builder-image</a>
<a class="mt-1 mb-1" href=/tags/chart>chart</a>
<a class="mt-1 mb-1" href=/tags/cloud>cloud</a>
<a class="mt-1 mb-1" href=/tags/container>container</a>
<a class="mt-1 mb-1" href=/tags/containers>containers</a>
<a class="mt-1 mb-1" href=/tags/copilot>copilot</a>
<a class="mt-1 mb-1" href=/tags/crd>crd</a>
<a class="mt-1 mb-1" href=/tags/cri>cri</a>
<a class="mt-1 mb-1" href=/tags/ctf>ctf</a>
<a class="mt-1 mb-1" href=/tags/cybersecurity>cybersecurity</a>
<a class="mt-1 mb-1" href=/tags/deployment>deployment</a>
<a class="mt-1 mb-1" href=/tags/distribution>distribution</a>
<a class="mt-1 mb-1" href=/tags/dockerhub>dockerhub</a>
<a class="mt-1 mb-1" href=/tags/docs-as-code>docs-as-code</a>
<a class="mt-1 mb-1" href=/tags/driver>driver</a>
<a class="mt-1 mb-1" href=/tags/encryption>encryption</a>
<a class="mt-1 mb-1" href=/tags/food>food</a>
<a class="mt-1 mb-1" href=/tags/github>github</a>
<a class="mt-1 mb-1" href=/tags/gpg>gpg</a>
<a class="mt-1 mb-1" href=/tags/helm>helm</a>
<a class="mt-1 mb-1" href=/tags/kubernetes>kubernetes</a>
<a class="mt-1 mb-1" href=/tags/limit>limit</a>
<a class="mt-1 mb-1" href=/tags/medium>medium</a>
<a class="mt-1 mb-1" href=/tags/oci>oci</a>
<a class="mt-1 mb-1" href=/tags/overthewire>overthewire</a>
<a class="mt-1 mb-1" href=/tags/pair-programming>pair-programming</a>
<a class="mt-1 mb-1" href=/tags/problem-solving>problem-solving</a>
<a class="mt-1 mb-1" href=/tags/programming>programming</a>
<a class="mt-1 mb-1" href=/tags/proxy>proxy</a>
<a class="mt-1 mb-1" href=/tags/rate>rate</a>
<a class="mt-1 mb-1" href=/tags/registry>registry</a>
<a class="mt-1 mb-1" href=/tags/runtime>runtime</a>
<a class="mt-1 mb-1" href=/tags/security>security</a>
<a class="mt-1 mb-1" href=/tags/sigstore>sigstore</a>
<a class="mt-1 mb-1" href=/tags/stream-cipher>stream-cipher</a>
<a class="mt-1 mb-1" href=/tags/thinkpad>thinkpad</a>
<a class="mt-1 mb-1" href=/tags/too-many-requests>too-many-requests</a>
<a class="mt-1 mb-1" href=/tags/troubleshooting>troubleshooting</a>
<a class="mt-1 mb-1" href=/tags/ubuntu>ubuntu</a>
<a class="mt-1 mb-1" href=/tags/verify>verify</a>
<a class="mt-1 mb-1" href=/tags/writing>writing</a></div></div></div><footer class=footer><div class=container><div class=row><div class="col-md-6 col-sm-6 text-center text-lg-left">&copy; Copyright Douglas Hellinger 2022 - Present</div><div class="col-md-6 col-sm-6 text-center text-lg-right"><a target=_blank rel=noopener href=https://www.wowthemes.net>Mediumish Theme</a> by WowThemes.net</div></div></div></footer></div><script src=https://code.jquery.com/jquery-3.4.1.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js integrity=sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut crossorigin=anonymous></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js integrity=sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM crossorigin=anonymous></script>
<script src=https://www.douglashellinger.com/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TEH3VGXMRY"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-TEH3VGXMRY",{anonymize_ip:!1})}</script></body></html>